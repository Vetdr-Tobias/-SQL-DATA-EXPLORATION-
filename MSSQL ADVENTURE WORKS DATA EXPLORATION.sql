-- MSSQL ADVENTURE WORKS DATA EXPLORATION 

-- SELECT-FROM STATEMENT
-- USED TO FETCH A SINGLE COLUMN, MULTIPLE COLUMNS OR ALL THE COLUMNS IN A TABLE

-- ALL COLUMNS (*)

SELECT * FROM Person.Person;

-- MULTIPLE COLUMNS 
SELECT BusinessEntityID, FirstName, LastName FROM Person.Person;

-- A SINGLE COLUMN 

SELECT FIRSTNAME FROM Person.Person;


-- REMOVING DUPLICATES
-- SELECT DISTINCT 

SELECT * FROM Production.Product;
SELECT LISTPRICE FROM Production.Product;

SELECT DISTINCT LISTPRICE FROM Production.Product;

SELECT * FROM Sales.SalesOrderDetail;
SELECT DISTINCT SALESORDERID FROM SALES.SalesOrderDetail; 

-- SORTING RESULTS 
-- ORDER BY 
-- ASC = ASCENDING = SMALLEST - BIGGEST LOWEST- HIGHEST
-- DESC = DESCENDING = HIGHEST - LOWEST/ BIGGEST - SMALLEST

SELECT FIRSTNAME, LASTNAME FROM Person.Person
ORDER BY FIRSTNAME ASC;

SELECT FIRSTNAME, LASTNAME FROM Person.Person
ORDER BY FIRSTNAME ;

SELECT FIRSTNAME, LASTNAME FROM Person.Person
ORDER BY LastName DESC;


-- LIMITING SORTED RECORDS 
-- USED TO LIMIT THE AMOUNT OF RECORDS SHOWN 
-- WE USE 'TOP'
SELECT TOP 10 FIRSTNAME, LASTNAME FROM Person.Person
ORDER BY LastName DESC

SELECT TOP 20 FIRSTNAME, LASTNAME FROM Person.Person
ORDER BY FirstName ASC;

-- FILTERING RECORDS
-- WHERE 

-- GET INFO ON THE PRODUCT KNOWN AS BLADE

SELECT * FROM Production.Product
WHERE NAME = 'BLADE';

-- GET INFO OF PRODUCTS WITH LISTPRICE GREATER THAN 1000

SELECT * FROM Production.Product
WHERE LISTPRICE > 1000
ORDER BY ListPrice ASC;


--  we want name, color and listprice of black products greater than 1000
-- SOLUTIONS

SELECT NAME, COLOR, LISTPRICE FROM Production.Product
WHERE COLOR = 'BLACK' AND ListPrice > 1000
ORDER BY LISTPRICE ASC;

-- we want name, color and listprice OF productS THAT ARE either less than $100 or greater than $1000
SELECT NAME, COLOR, LISTPRICE FROM Production.Product
WHERE LISTPRICE < 100 OR ListPrice > 1000;

-- LIKE STATEMENT
-- The LIKE operator is used in a WHERE clause to search for a specified pattern in a column. 
-- % = WHEN WE ARE NOT SURE OF THE NUMBER OF CHARACTERS
-- _ = WHEN WE ARE SURE, ONE _ MEANS ONE CHARACTER
-- IN MSSQL SERVER, IT IS NOT CASE SENSITIVE, WHEREAS IN OTHER BRAND OF SQL E.G. POSTGRESQL, IT IS CASE SENSITIVE 

-- INFO ON PRODUCTS THAT STARTS WITH BEARING 
SELECT * FROM Production.Product
WHERE NAME LIKE 'BEARING%'

SELECT * FROM Production.Product
WHERE NAME = 'BEARING'

-- WE WANT BUSINESSENTITITYID, FIRSTNAME, LASTNAME OF PEOPLE WHOSE FIRST NAMES END WITH ER
SELECT BusinessEntityID, FirstName, LastName FROM Person.Person
WHERE FIRSTNAME LIKE '%ER';

-- WE WANT FIRSTNAME, LASTNAME OF THOSE WHOSE FIRST NAME STARTS WITH A AND THOSE WHOSE LAST NAME STARTS WITH W
SELECT FIRSTNAME, LASTNAME FROM Person.Person
WHERE FIRSTNAME LIKE 'A%' AND LastName LIKE 'Z%';


-- IN STATEMENT 
-- In statement is used to replace multiple =

-- GIVE INFO ON name, color and listprice OF PRODUCTS THAT ARE BLACK AND RED 
SELECT NAME, COLOR, LISTPRICE FROM Production.Product
WHERE COLOR = 'BLACK' OR COLOR = 'RED'

-- GIVE INFO ON name, color and listprice OF PRODUCTS THAT ARE BLACK, RED AND BLUE
SELECT NAME, COLOR, LISTPRICE FROM Production.Product
WHERE COLOR = 'BLACK' OR COLOR = 'RED' OR COLOR = ' BLUE';

-- USING IN
SELECT NAME, COLOR, LISTPRICE 
FROM Production.Product 
WHERE COLOR IN ('BLACK', 'RED', 'BLUE') 
ORDER BY COLOR

-- NOT IN 
SELECT NAME, COLOR, LISTPRICE FROM Production.Product
WHERE COLOR NOT IN ('BLACK', 'RED', 'BLUE')
ORDER BY COLOR

-- BETWEEN 
-- USED WHEN WE HAVE RANGE OF VALUES
-- USED TO REPLACE <= OR >=

-- WE WANT PRODUCT WHOSE PRICES ARE GREATER THAN 100 AND LESS THAN 500

SELECT NAME, COLOR, LISTPRICE FROM Production.Product
WHERE LISTPRICE >= 100 AND LISTPRICE <= 500;

SELECT NAME, COLOR, LISTPRICE FROM Production.Product
WHERE ListPrice BETWEEN 100 AND 500;

-- NOT BETWEEN 
SELECT NAME, COLOR, LISTPRICE FROM Production.Product
WHERE ListPrice NOT BETWEEN 100 AND 500
ORDER BY 3;


-- DISPLAY LEAST 5 LISTPRICES
SELECT DISTINCT TOP 5 LISTPRICE FROM PRODUCTION.Product
ORDER BY 1 DESC;

SELECT DISTINCT TOP 5 LISTPRICE FROM PRODUCTION.Product
ORDER BY 1;

-- TOP DOESNT MEAN THE HIGHEST INSTEAD IT IS USED TO LIMIT THE ROWS 


-- AGGREGATES FUNTIONS
-- THEY FOLLOW THE  SELECT STATEMENT
-- THEY CHANGE THE COLUMN NAME
-- THEY COLUMN WE ARE AGGREGATING IS USUALLY PUT IN ()

-- MIN = FIND THE MINIMUMN VALUE 
-- MINIMUM PRICE IN OUR STORE

SELECT MIN (LISTPRICE) FROM Production.Product;

-- MAX 
-- GIVES THE HIGHEST VALUE
SELECT MAX (LISTPRICE) FROM Production.Product;

-- AVG
-- GIVES THE MEAN OF VALUES
SELECT AVG (LISTPRICE) FROM Production.Product;

-- VAR
-- GIVES THE VARIANCE OF VALUES

SELECT VAR (LISTPRICE) FROM Production.Product;

-- COUNT
-- COUNTS THE NUMBER OF VALUES
SELECT COUNT (LISTPRICE) FROM Production.Product;

-- SUM 
-- SUMS UP ALL THE VALUES 
SELECT SUM (LISTPRICE) FROM Production.Product;

-- ALIASING 
-- (AS)
-- USED TO CHANGE THE COLUMN OR TABLE NAME 
SELECT SUM (LISTPRICE) AS SUM_OF_LISTPRICES FROM Production.Product;

SELECT SUM(LISTPRICE) SUM_OF_LISTPRICES FROM Production.Product;

SELECT MIN (LISTPRICE) MIN_PRICE FROM Production.Product;


-- JOIN
-- USED TO MERGE TWO OR MORE TABLES TOGETHER
-- THEY MUST SATISFY A MATCHING CRITERIA
-- IT IS BASED ON PRI-FOREIGN KEY RELATONSHIP


-- HOW TO JOIN
-- IDENTIFY THE TABLES WE ARE JOINING 
-- TAKE NOTE OF THE RELATIONSHIP KEYS (PRIMARY & FOREIGN KEYS)
-- TAKE NOTE OF THE COLUMNS NEEDED AND THE TABLE THE COLUMNS APPEAR 
-- STATE THE JOIN TYPE 
-- ADD THE SECOND TABLE 
-- INTRODUCE THE JOINING CONDITION = (ON) WITH RELATIONSHIP
-- TO AVOID AMBIGOUS COLUMN;
	-- WE CAN ALIAS OUR TABLES NAMES 
	-- WE USE THE TABLE.COLUMNNAME FOR THE AMBIGOUS COLUMN


-- TYPES OF JOINS 
-- 3 TYPES OF JOINS 

-- INNER JOIN 
-- SHOWS ONLY THE MATCHING ROWS IN BOTH TABLES 


-- SHOW THE NAMES OF THE EMPLOYEES
SELECT * FROM HumanResources.Employee;
-- BUSINESSENTITYID, JOBTITLE
SELECT * FROM Person.Person;
-- BUSINESSENTITYID, FIRSTNAME, MIDDLENAME, LASTNAME

SELECT HumanResources.Employee.BusinessEntityID, JOBTITLE, PERSON.PERSON.BUSINESSENTITYID, FIRSTNAME, MIDDLENAME, LASTNAME
FROM HumanResources.Employee INNER JOIN PERSON.PERSON 
ON HumanResources.Employee.BusinessEntityID = PERSON.PERSON.BusinessEntityID;

-- USING TABLENAME ALIASES

SELECT HRE.BusinessEntityID, JOBTITLE, PP.BUSINESSENTITYID, FIRSTNAME, MIDDLENAME, LASTNAME
FROM HumanResources.Employee AS HRE INNER JOIN PERSON.PERSON PP
ON HRE.BusinessEntityID = PP.BusinessEntityID;

SELECT HRE.BusinessEntityID, JOBTITLE, FIRSTNAME, MIDDLENAME, LASTNAME
FROM HumanResources.Employee AS HRE INNER JOIN PERSON.PERSON PP
ON HRE.BusinessEntityID = PP.BusinessEntityID;


-- OUTER JOIN 
-- LEFT OUTER
--- SHOW CUSTOMERS WHETHER THEY HAVE ORDERED OR NOT  
SELECT * FROM SALES.Customer
-- CUSTOMERID 

SELECT * FROM SALES.SalesOrderHeader
-- SALESORDERID, SALESORDERNUMBER, CUSTOMERID 

SELECT SC.CUSTOMERID, SALESORDERID, SALESORDERNUMBER, SOH.CUSTOMERID
FROM SALES.Customer SC LEFT JOIN SALES.SalesOrderHeader SOH
ON SC.CUSTOMERID = SOH.CustomerID

-- SHOW ALL PRODUCT,NAME, COLOR,  SALES ORDER OF PRODUCTS EVEN IF THEY HAVE NOT BEEN ORDERED BEFORE

SELECT * FROM Production.Product;
-- PRODUCTID, NAME, COLOR
SELECT * FROM Sales.SalesOrderDetail
-- SALESORDERID, PRODUCTID, LINETOTAL 

SELECT PP.PRODUCTID, NAME, COLOR, SALESORDERID, SOD.PRODUCTID, LINETOTAL
FROM Production.Product PP LEFT JOIN SALES.SalesOrderDetail SOD
ON PP.PRODUCTID = SOD.PRODUCTID

-- RIGHT OUTER 

SELECT PP.PRODUCTID, NAME, COLOR, SALESORDERID, SOD.PRODUCTID, LINETOTAL
FROM Production.Product PP RIGHT JOIN SALES.SalesOrderDetail SOD
ON PP.PRODUCTID = SOD.PRODUCTID
ORDER BY PP.ProductID

-- FULL OUTER 
-- TAKES EVERYTHING AND MERGE

SELECT PP.PRODUCTID, NAME, COLOR, SALESORDERID, SOD.PRODUCTID, LINETOTAL
FROM Production.Product PP FULL OUTER JOIN SALES.SalesOrderDetail SOD
ON PP.PRODUCTID = SOD.PRODUCTID
ORDER BY PP.ProductID


SELECT HRE.BusinessEntityID, JOBTITLE, FIRSTNAME, MIDDLENAME, LASTNAME
FROM HumanResources.Employee AS HRE FULL JOIN PERSON.PERSON PP
ON HRE.BusinessEntityID = PP.BusinessEntityID;

-- SELF JOIN 


-- NULLIF
-- COALESCE
-- ISNULL


-- GROUP BY 
-- GROUP ROWS TOGETHER 
-- MAJORLY USED WITH AGGREGATE FUNTIONS 

SELECT * FROM SALES.SalesOrderDetail

-- GET THE TOTAL AMOUNT FOR EACH SALESORDER
SELECT SalesOrderID, LineTotal  FROM SALES.SalesOrderDetail;

SELECT SalesOrderID, SUM(LineTotal) TOTAL_AMOUNT  FROM SALES.SalesOrderDetail
GROUP BY SalesOrderID;

-- HAVING 
-- IS USED TO FILTER GROUPED RECORDS 
-- IT DOES EVERYTHING A WHERE CAN DO 
-- WE CAN USE LIKE, BETWEEN, <,>, =, IN, NOT IN ETC

-- WE WANT TO KNOW THE PRODUCTS WHICH TOTAL SALES IS GREATER THAN 10000 AND AMOUNT OF THAT PRODUCT SOLD

SELECT * FROM SALES.SalesOrderDetail

SELECT PRODUCTID, SUM(LINETOTAL) TOTAL_AMOUNT, COUNT(PRODUCTID) PRD_QTY FROM SALES.SalesOrderDetail
GROUP BY ProductID
HAVING SUM(LineTotal) > 10000;

-- IF WE WANT TO GET OUR MOST PERFORMING PRODUCT, HOW DO WE GO ABOUT IT? 
-- WE WANT TO KNOW THE NAMES PRODUCTS WHICH TOTAL SALES IS GREATER THAN 10000 AND AMOUNT OF THAT PRODUCT SOLD?
-- USE JOINS


-- CREATE TABLES 
-- 01: WE USE THE SYNTAX = CREATE TABLE TABLENAME ()
-- 02: WE ADD THE COLUMN NAMES WITHIN THE BRACKETS
-- 03: WE ADD THE DATATYPES TO EACH COLUMN
-- 04: WE SPECIFY RELATIONSHIP (PRIMARY, ETC)
-- 05: WE ADD CONSTRAINT (UNIQUE, NOT NULL, IDENTITY)
-- IDENTITY = USED TO AUTOMATE VALUES E.G 1,2,3,4,5

SELECT * FROM Person.Person;

CREATE TABLE SEMESTER1(
STUDENT_ID INT PRIMARY KEY IDENTITY(1,1),
NAME VARCHAR(50) NOT NULL,
COURSE VARCHAR(10) NOT NULL,
SCORES INT NOT NULL
);

-- INSERT INTO TABLES 
INSERT INTO SEMESTER1 (NAME, COURSE, SCORES)
VALUES 
('ODUNAYO', 'POWERBI', '29'),
('DOLAPO', 'MSSQL', '28'),
('ADAM', 'EXCEL', '27');

SELECT * FROM SEMESTER1;

CREATE TABLE SEMESTER2(
STUDENT_ID INT PRIMARY KEY IDENTITY(1,1),
NAME VARCHAR(50) NOT NULL,
COURSE VARCHAR(10) NOT NULL,
SCORES INT NOT NULL
);
-- SECOND METHOD OF INSERTING 

SELECT * FROM SEMESTER2;

-- delete tables 
-- we use DROP 
--DROP TABLE SEMESTER1;


SELECT * FROM SEMESTER1;
-- SET OPERATORS 
-- USED TO COMNBINE TWO OR MORE SELECT STATMENTS
-- rules
-- no of columns must be the same
-- order of columns must be the same 
-- datatypes of the columns must be the same


-- UNION
-- USED TO COMNBINE TWO OR MORE SELECT STATMENTS WITHOUT DUPLICATES

SELECT * FROM SEMESTER1 
union
select * from SEMESTER2

SELECT STUDENT_ID, SCORES FROM SEMESTER1 
union
select STUDENT_ID, scores from SEMESTER2;

-- UNION ALL
-- USED TO COMNBINE TWO OR MORE SELECT STATMENTS WITH DUPLICATES
SELECT * FROM SEMESTER1 
union all
select * from SEMESTER2

-- INTERSECT
-- returns only the common value in the two select statement
SELECT * FROM SEMESTER1 
intersect
select * from SEMESTER2

-- EXCEPT
-- shows all the records on the left table but on the right table 
-- it also called minus
SELECT * FROM SEMESTER1 
except
select * from SEMESTER2

-- MISCELLANEOUS
-- CONNECT WITH ME ON LINKEDIN
-- Chidubem Tobias
-- https://www.linkedin.com/in/chidubem-tobias/

-- THANKS FOR looking in!!! 
